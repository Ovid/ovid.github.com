#!/usr/bin/env perl

use v5.40;
use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use File::Spec;
use File::Basename qw(basename dirname);
use Cwd qw(abs_path);

# CLI argument parsing
my %options = (
    module => '',
    output => '',
    format => 'text',
    help   => 0,
);

GetOptions(
    'module=s' => \$options{module},
    'output=s' => \$options{output},
    'format=s' => \$options{format},
    'help'     => \$options{help},
) or die "Error in command line arguments\n";

# Show help if requested
if ($options{help}) {
    print_usage();
    exit 0;
}

# Validate required arguments
unless ($options{module}) {
    print_usage();
    exit 1;
}

# Validate format
unless ($options{format} =~ /^(json|text)$/) {
    die "Error: --format must be 'json' or 'text'\n";
}

# Validate module file exists
unless (-f $options{module}) {
    print STDERR "Error: Module file not found: $options{module}\n";
    exit 1;
}

# Main execution
eval {
    my $analysis = analyze_module($options{module});
    my $output = format_output($analysis, $options{format});
    
    if ($options{output}) {
        write_output($options{output}, $output);
    } else {
        print $output;
    }
};

if ($@) {
    print STDERR "Error: $@\n";
    exit 2;
}

exit 0;

# Helper Functions

sub print_usage {
    print "Usage: $0 --module <path> [--output <file>] [--format <json|text>] [--help]\n";
    print "\n";
    print "Options:\n";
    print "  --module <path>   Path to module file to analyze (required)\n";
    print "  --output <file>   Output file for report (default: stdout)\n";
    print "  --format <type>   Output format: 'json' or 'text' (default: text)\n";
    print "  --help            Show this help message\n";
    print "\n";
    print "Examples:\n";
    print "  $0 --module lib/Ovid/Site.pm\n";
    print "  $0 --module lib/Ovid/Site.pm --format json\n";
    print "  $0 --module lib/Ovid/Site.pm --output analysis.txt\n";
}

# Placeholder functions to be implemented
sub analyze_module ($module_path) {
    my @methods = extract_methods($module_path);
    
    # Determine workspace root (go up from module path to find project root)
    my $workspace_root = find_workspace_root($module_path);
    
    # For each method, search for call sites
    for my $method (@methods) {
        my @call_sites = find_method_calls($method->{name}, $workspace_root);
        
        $method->{call_count} = scalar @call_sites;
        $method->{call_locations} = \@call_sites;
        $method->{potentially_unused} = (@call_sites == 0) ? 1 : 0;
    }
    
    return {
        module => $module_path,
        methods => \@methods,
    };
}

sub find_workspace_root ($module_path) {
    my $abs_path = abs_path($module_path);
    my $dir = dirname($abs_path);
    
    # Walk up until we find a directory containing lib/, bin/, or t/
    while ($dir ne '/' && $dir ne '.') {
        if (-d File::Spec->catdir($dir, 'lib') || 
            -d File::Spec->catdir($dir, 'bin') || 
            -d File::Spec->catdir($dir, 't')) {
            return $dir;
        }
        $dir = dirname($dir);
    }
    
    # Fallback to current directory
    return Cwd::getcwd();
}

sub extract_methods ($module_path) {
    open my $fh, '<', $module_path or die "Cannot read $module_path: $!\n";
    my @lines = <$fh>;
    close $fh;
    
    my @methods;
    my $in_pod = 0;
    
    for my $i (0 .. $#lines) {
        my $line = $lines[$i];
        
        # Track POD sections
        if ($line =~ /^=\w+/) {
            $in_pod = 1;
            next;
        }
        if ($line =~ /^=cut/) {
            $in_pod = 0;
            next;
        }
        
        next if $in_pod;
        next if $line =~ /^\s*#/;  # Skip comments
        
        # Match subroutine definitions
        # Handles: sub name, sub name ($params), sub name :exported, etc.
        if ($line =~ /^\s*sub\s+([a-zA-Z_]\w*)\s*[\(\{:]/) {
            my $method_name = $1;
            
            # Skip private methods (starting with _)
            next if $method_name =~ /^_/;
            
            push @methods, {
                name => $method_name,
                call_count => 0,
                call_locations => [],
                potentially_unused => 1,  # Will be updated by usage search
            };
        }
    }
    
    return @methods;
}

sub find_method_calls ($method_name, $workspace_root) {
    my @call_sites;
    my @search_dirs = ('lib', 'bin', 't');
    
    for my $dir (@search_dirs) {
        my $full_path = File::Spec->catdir($workspace_root, $dir);
        next unless -d $full_path;
        
        my @files = find_perl_files($full_path);
        
        for my $file (@files) {
            my @locations = search_file_for_method($file, $method_name);
            push @call_sites, @locations;
        }
    }
    
    return @call_sites;
}

sub find_perl_files ($dir) {
    my @files;
    
    opendir my $dh, $dir or return @files;
    my @entries = readdir $dh;
    closedir $dh;
    
    for my $entry (@entries) {
        next if $entry eq '.' || $entry eq '..';
        
        my $path = File::Spec->catfile($dir, $entry);
        
        if (-d $path) {
            push @files, find_perl_files($path);
        } elsif ($entry =~ /\.(pm|pl|t)$/ || (-f $path && -x $path)) {
            push @files, $path;
        }
    }
    
    return @files;
}

sub search_file_for_method ($filepath, $method_name) {
    my @locations;
    
    open my $fh, '<', $filepath or return @locations;
    my @lines = <$fh>;
    close $fh;
    
    my $in_pod = 0;
    
    for my $i (0 .. $#lines) {
        my $line = $lines[$i];
        
        # Track POD sections
        if ($line =~ /^=\w+/) {
            $in_pod = 1;
            next;
        }
        if ($line =~ /^=cut/) {
            $in_pod = 0;
            next;
        }
        
        next if $in_pod;
        next if $line =~ /^\s*#/;  # Skip full-line comments
        
        # Look for method calls: ->method, ::method, or method(
        # But skip the definition line itself
        if ($line =~ /(?:->|::|\s)$method_name\s*[\(\{]/ && $line !~ /^\s*sub\s+$method_name\b/) {
            my $line_num = $i + 1;
            push @locations, "$filepath:$line_num";
        }
    }
    
    return @locations;
}

sub format_output ($analysis, $format) {
    if ($format eq 'json') {
        return format_json($analysis);
    } else {
        return format_text($analysis);
    }
}

sub format_json ($analysis) {
    require JSON::PP;
    my $json = JSON::PP->new->pretty->canonical;
    return $json->encode($analysis);
}

sub format_text ($analysis) {
    my $output = "Module: $analysis->{module}\n";
    
    if (@{$analysis->{methods}} == 0) {
        $output .= "  No methods found\n";
    } else {
        for my $method (@{$analysis->{methods}}) {
            $output .= "Method: $method->{name}\n";
            $output .= "  Calls: $method->{call_count}\n";
            $output .= "  Locations: ";
            if (@{$method->{call_locations}}) {
                $output .= join(", ", @{$method->{call_locations}}) . "\n";
            } else {
                $output .= "(none)\n";
            }
            $output .= "  Status: " . ($method->{potentially_unused} ? "potentially unused" : "used") . "\n";
            $output .= "\n";
        }
    }
    
    return $output;
}

sub write_output ($filepath, $content) {
    eval {
        open my $fh, '>', $filepath or die "Cannot write to $filepath: $!\n";
        print {$fh} $content;
        close $fh or die "Error closing $filepath: $!\n";
    };
    if ($@) {
        print STDERR "Error writing output: $@";
        exit 3;
    }
}

__END__

=head1 NAME

analyze-usage - Analyze method/function usage across the codebase

=head1 SYNOPSIS

    analyze-usage --module <path> [--output <file>] [--format <json|text>]

=head1 DESCRIPTION

Scans the codebase to identify method/function usage patterns for the specified module.
Helps identify potentially unused code before writing tests.

=head1 OPTIONS

=over 4

=item --module <path>

Path to the module file to analyze (required).

=item --output <file>

Output file for the analysis report. Defaults to stdout.

=item --format <json|text>

Output format: 'json' or 'text'. Defaults to 'text'.

=back

=head1 EXIT CODES

=over 4

=item 0 - Success

=item 1 - Module file not found

=item 2 - Failed to parse module or analysis error

=item 3 - Cannot write output file

=back

=head1 AUTHOR

Generated for test coverage improvement project

=cut
