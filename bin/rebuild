#!/usr/bin/env perl

# vim: ft=perl
use lib 'lib';
use strict;
use warnings;

use DateTime;
use DateTime::Format::SQLite;
use XML::RSS;
use Mojo::DOM;
use Mojo::JSON qw(encode_json);

use Less::Config qw(
  config
);
use Less::Script;
use Less::Pager;
use Less::TTSyntax qw(
  simplify_tt_code
);

use HTML::TokeParser::Simple;
use Capture::Tiny 'capture';

use File::Find::Rule;
use File::Spec::Functions qw(catfile catdir);
use File::Basename qw(dirname basename);
use File::Path qw(mkpath);
use File::Copy;


assert_tt_config();
my @files = File::Find::Rule->file->in('root');
my $tagmap = preprocess_files(@files);
write_tagmap($tagmap);
rebuild_article_pagination();
rebuild_rss_feeds();
run_ttree();
system( 'prove', '-l', 't' );
exit 0;

sub write_tagmap($tagmap) {
    foreach my $tag ( keys $tagmap->%* ) {
        $tagmap->{$tag}{files} = [sort $tagmap->{$tag}{files}->@*];
    }
    splat( config()->{tagmap_file}, encode_json($tagmap) );
}
sub preprocess_files (@files) {

    # scrub our tmp directory
    system( 'rm', '-fr', 'tmp' );

    # format:
    #     $tag => {
    #         name  => $tagname,
    #         files => [$destfile. $destfile, ... ]
    my %tagmap;
  FILE: foreach my $file (@files) {
        next FILE if $file =~ /\.sw\w$/;    # ignore vim swapfiles
        my $is_tt_file = $file =~ /\.tt(?:2markdown)?$/;

        my $dir  = dirname($file);
        my $name = basename($file);

        if ( $dir !~ /static/ && !$is_tt_file ) {
            next FILE;
        }

        # make sure we have our destination directory
        my $destdir = $dir;
        $destdir =~ s/^root/tmp/;
        unless ( -d $destdir ) {
            mkpath($destdir);
        }

        my $destfile = catfile( $destdir, $name );

        if ( !$is_tt_file ) {

            # not a template toolkit file? Copy it over directly
            copy( $file, $destfile )
              or croak("Could not copy $file to $destfile: $!");
        }
        else {
            # ah, crap. We need to pre-process it.
            my $contents = slurp($file);

            my $config = config();
            if ($is_tt_file) {
                if ( $contents =~ /^\s*\{\{TOC\}\}\s*$/m ) {
                    $contents = build_toc( $file, $contents );
                }
                if ( $contents =~ /^\s*\{\{TAGS\s+(.*?)\}\}\s*$/m ) {
                    my $title = get_title_from_template($contents);
                    unless ($title) {
                        croak("Tags found for '$file' but could not determine title");
                    }
                    my @tags = split /\s+/ => $1;
                    foreach my $tag (@tags) {
                        if ( my $name = $config->{tagmap}{$tag} ) {
                            $tagmap{$tag}{name} = $name;
                            $tagmap{$tag}{count}++;
                            $tagmap{$tag}{files} //= [];

                            # XXX nasty hack alert
                            my $url = $destfile;
                            $url =~ s{^tmp/}{};
                            $url =~ s/\.tt(?:2markdown)?$/.html/;
                            $tagmap{$tag}{titles}{$url} = $title;
                            push $tagmap{$tag}{files}->@* => $url;
                        }
                        else {
                            die
"No tagmap: entry found for tag '$tag' in file '$file'";
                        }

                    }
                }
            }

            eval {
                $contents = simplify_tt_code($contents);
                1;
            } or do {
                my $error = $@ || "Unknown error";
                die "$file had error error: $error\n";
            };

            splat( $destfile, $contents );
        }
    }
    return \%tagmap;
}

sub get_title_from_template ($contents ) {
    # many pages don't have titles, so it's ok to skip them
    if ( $contents =~
        m{(.*)\[%.*WRAPPER include/wrapper.*(?:blogdown=1.*)?%\]}s )
    {
        my $header = $1;
        foreach my $line ( split /\n/ => $header ) {
            my ( $key, $value ) = map { trim($_) } split /=/ => $line;
            next if 'title' ne $key;
            $value =~ s/;$//;
            $value =~ s/^['"]//;
            $value =~ s/['"]$//;
            return $value if 'title' eq $key;
        }
    }
    return;
}

sub build_toc ( $file, $contents ) {

    # XXX this is a simplistic heuristic. Need something better in the future.
    if ( $contents =~ m{\[%.*WRAPPER include/wrapper.*blogdown=1.*%\]} ) {

        # we need to preprocess the markdown, replacing '#' headers with their
        # appropriate HTML tag. This allows the subsequent HTML parsing logic
        # to build the TOC, but still allows the bulk of Markdown processing
        # to happen in the templates, where it should be.
        my %replacement_for;
        while ( $contents =~ /^((#+)\s*(.*))$/mg ) {
            my $title = $3;
            my $line  = $1;
            my $level = length($2);
            my $h_tag = "<h$level>$title</h$level>";
            $replacement_for{$line} = $h_tag;
        }
        while ( my ( $line, $tag ) = each %replacement_for ) {
            $contents =~ s/\Q$line/$tag/;
        }
    }
    my $p = HTML::TokeParser::Simple->new( string => $contents );

    state $seen = {};

    my $rewritten = '';
    my @links;
    while ( my $token = $p->get_token ) {
        if ( $token->is_start_tag(qr/^h[1-6]$/i) ) {
            $rewritten .= $token->as_is;
            my $tag = $token->get_tag;
            $tag =~ /^h([1-6])$/i or croak("Bad 'h' tag in $file: $tag");
            my $level = $1;
            my $title = $p->peek(1);
            my $slug  = make_slug($title);
            if ( $seen->{$file}{$slug}++ ) {
                croak("Already seen heading '$title/$slug' in '$file'");
            }
            $rewritten .= qq{<a name="$slug"></a>};
            push @links =>
qq{    <li class="indent-$level"><a href="#$slug">$title</a></li>};
        }
        else {
            $rewritten .= $token->as_is;
        }
    }
    my $links = join "\n" => @links;
    my $toc   = <<"TOC";
<nav role="navigation" class="table-of-contents">
    <ul>
$links
    </ul>
</nav>
<hr>
TOC
    # rewrite the table of contents
    $rewritten =~ s/^s*\{\{TOC\}\}\s*$/$toc/m;

    # remove the tags
    $rewritten =~ s/^s*\{\{TAGS.*?\}\}\s*$//m;

    return $rewritten;
}

sub rebuild_article_pagination () {
    foreach my $type (qw/article blog/) {
        my $article_type = article_type($type);
        my $pager        = Less::Pager->new( type => $type );
        while ( my $records = $pager->next ) {
            my $page_number = $pager->current_page_number;
            my $title       = "$article_type->{name} by Ovid";
            if ( $pager->total_pages > 1 ) {
                $title .= ", page $page_number";
            }
            my $articles   = get_article_list( $records, $article_type );
            my $pagination = get_pagination( $pager->total_pages, $page_number,
                $article_type );
            my $template = <<"END";
[%
    title      = '$title';
    identifier = 'articles';
%]

[% INCLUDE include/header.tt %]

$articles
$pagination
[% IF $page_number == 1 -%]
<script>
    var latestArticle  = document.getElementById("articles").firstElementChild.innerHTML;
    document.getElementById("articles").firstElementChild.innerHTML = '<em>' + latestArticle + '</em> <span class="new">New!</span>'
</script>
[%- END %]

[% INCLUDE include/footer.tt %]
END
            my $article = article_page( $page_number, $article_type );
            splat( "root/$article.tt", $template );
        }
    }
}

sub rebuild_rss_feeds () {
    my $base_url = 'https://ovid.github.io/';

    my $types =
      dbh()
      ->selectall_arrayref(
        'SELECT name, type, directory, description FROM article_types',
        { Slice => {} } );

    foreach my $type ( $types->@* ) {
        my $rss_file  = "$type->{type}.rss";
        my %already_added;
        if ( -e $rss_file ) {
            my $dom = Mojo::DOM->new(slurp($rss_file));
            %already_added = map { $_->text => 1 } $dom->find('link')->each;
        }
        my $directory = $type->{directory};
        my $now       = DateTime->now;
        my $year      = $now->year;
        my $rss       = XML::RSS->new( version => '2.0' );
        $rss->add_module(
            prefix => 'atom',
            uri    => 'http://www.w3.org/2005/Atom'
        );
        $rss->channel(
            title       => $type->{description},
            link        => "$base_url$directory",
            description => $type->{description},
            language    => 'en-us',
            copyright   => "Copyright $year, Curtis \"Ovid\" Poe",
            atom        => {
                'link' => {
                    'href' => "$base_url$type->{type}.rss",
                    'rel'  => 'self',
                    'type' => 'application/rss+xml'
                }
            },

            # RSS 2.0 requires RFC822 dates
            pubDate        => $now->strftime("%a, %d %b %Y %H:%M:%S %z"),
            managingEditor => 'curtis.poe@gmail.com (Curtis "Ovid" Poe)',
        );
        my $articles =
          dbh()->selectall_arrayref( <<"SQL", { Slice => {} }, $type->{type} );
    SELECT a.title,
           a.slug,
           a.description,
           a.created
      FROM articles a
      JOIN article_types at ON at.article_type_id = a.article_type_id
     WHERE available = 1 AND at.type = ?
  ORDER BY sort_order DESC
SQL

        my $new_links = 0;
        foreach my $article ( $articles->@* ) {
            my $created =
              DateTime::Format::SQLite->parse_datetime( $article->{created} );
            my $url = "$base_url$directory/$article->{slug}.html";

            # Every time we changed an article, we kept updating the
            # publication date of the entire RSS feed. Now we only do this if
            # we have found at least one new article/blog entry.
            $new_links++ if not $already_added{$url};

            $rss->add_item(
                title       => $article->{title},
                link        => $url,
                description => $article->{description},
                creator     => 'Curtis "Ovid" Poe',
                guid        => "$type->{type}/$article->{slug}",
                pubDate     => $created->strftime("%a, %d %b %Y %H:%M:%S %z"),
            );
        }
        splat( $rss_file, $rss->as_string ) if $new_links;
    }
}

sub get_pagination ( $total, $current, $article_type ) {
    return '' if $total == 1;
    my $pagination = qq{<nav class="pagination">\n};
    if ( $current > 1 ) {
        my $prev    = $current - 1;
        my $article = article_page( $prev, $article_type );
        $pagination .= qq{    <a href="/$article.html">&laquo;</a>\n};
    }
    else {
        $pagination .= qq{    <span class="inactive">&laquo;</span>\n};
    }
    for my $page ( 1 .. $total ) {
        my $class   = $page == $current ? 'class="active"' : '';
        my $article = article_page( $page, $article_type );
        $pagination .= qq{    <a $class href="/$article.html">$page</a>\n};
    }
    if ( $current < $total ) {
        my $next    = $current + 1;
        my $article = article_page( $next, $article_type );
        $pagination .= qq{    <a href="/$article.html">&raquo;</a>\n};
    }
    else {
        $pagination .= qq{    <span class="inactive">&raquo;</span>\n};
    }
    $pagination .= "</nav>";
    return $pagination;
}

sub article_page ( $number, $article_type ) {
    my $directory = $article_type->{directory};
    return 1 == $number ? $directory : "${directory}_$number";
}

sub get_article_list ( $records, $article_type ) {
    my $list = qq{<ul id="articles">\n};
    foreach my $article ( $records->@* ) {
        $list .=
qq{    <li><a href="/$article_type->{directory}/$article->{slug}.html">$article->{title}</a></li>\n};
    }
    $list .= "</ul>";
    return $list;
}

sub assert_tt_config {
    unless ( -f "$ENV{HOME}/.ttreerc" ) {
        warn <<"END";
No $ENV{HOME}/.ttreerc file found

It should have a structure like this:

	verbose
	recurse

	color=1

	src  = ~/Dropbox/Mine/projects/perl/ovid.github.com/root
	dest  = ~/Dropbox/Mine/projects/perl/ovid.github.com/

	ignore = \b(CVS|RCS|sw[pot])\b
	ignore = ^#
	ignore = ^.git

	suffix tt=html
	suffix tt2markdown=html
END
        exit 1;
    }
}

sub run_ttree {
    my ( $stdout, $stderr, $exit ) = capture {
        system(
            'ttree',      '-a',                     # process all files
            '-s',         'tmp',                    # use tmp/ as a source
            '-d',         '.',                      # use . as the target
            '--copy',     '\.(gif|png|jpg|pdf)$',   # copy, don't process images
            '--binmode',  'utf8',                   # encoding of output file
            '--encoding', 'utf8',                   # encoding of input files
        )
    };

    if ( $stdout =~ /!.*file error/ ) {

        # yeah, ttree needs proper exit codes
        croak($stdout);
    }
    say $stdout;
}

__END__

=head1 NAME

rebuild - Rebuilds site

=head1 DESCRIPTION

=over 4

=item * Preprocesses files (such as adding TOCs and TAGS)

=item * Runs C<ttree>

=item * Runs all tests

=item * Rebuilds article pagination

=back
