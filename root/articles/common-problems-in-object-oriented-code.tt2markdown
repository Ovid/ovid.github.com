[%
    title            = 'Common Problems in Object-Oriented Code';
    type             = 'articles';
    slug             = 'common-problems-in-object-oriented-code';
    include_comments = 1;
    syntax_highlight = 1;
    date             = '2022-04-17';
    mathjax          = 0;
    # facebook         = 'babylon.jpg'; # 1,200 x 628 pixels recommended, but can be smaller
    # facebook_alt     = 'A cuneiform tablet with Babylonian numbers inscribed on it.';
    USE Ovid;
%]
[% WRAPPER include/wrapper.tt blogdown=1 -%]

{{TOC}}

{{TAGS oop programming corinna perl}}

After spending almost three years as the lead designer of the [Corinna
object system for the Perl core](https://github.com/Ovid/Cor), I'm quite
delighted that work on including this in the Perl language will start soon.
Until it's there, [our company](https://allaroundtheworld.fr/) still does lot
of work with object-oriented code (OOP) and we've seen some very common causes
of failures.  Much of what follows deals with the issues we've had with client
code, so this is a practical guide.

This is not an exhaustive list of best practices, but it covers many common
problems and offers tips for avoiding these problems. Note that much of what
follows are rules of thumb, not absolute laws.

# What's an Object?

First and foremost, we must keep in mind what an object is. [I cover this a
bit more in-depth in other
articles](/articles/why-is-object-oriented-programming-bad.html), but for this
one, just keep in mind that an object is an expert about a particular topic.
Forget all of those other explanations about objects being "structs with
behavior", or "a reference to a data type that knows what class it belongs to."
Those are implementation details that don't tell you objects are _for_. Objects
are experts on a particular problem space, that's all.

# Recommendations

I could talk about [SOLID](https://en.wikipedia.org/wiki/SOLID),
[GRASP](https://en.wikipedia.org/wiki/GRASP_\(object-oriented_design\)), the
[Liskov substitution
principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle), the
[Law of Demeter](https://en.wikipedia.org/wiki/Law_of_Demeter), and so on, but
while those are important, you can read about those on your own. Instead, I'll
get right to the heart of many common issues.

## Immutable Objects

I've written before why [immutable objects are
good](/articles/using-immutable-datetime-objects-with-dbixclass.html), so I
won't go into too much detail. Sometimes it's not practical to have immutable
objects (e.g., caches), but immutability should be your _default_ position. In
most languages, objects are passed by reference, not values. The more widely
used an instance of your object is, if it's mutable, the more likely that code
"A" will change the state in a way that code "B" didn't expect.

### Recommendation

Even if you're not convinced, try writing and using immutability objects. Like
anything new, it can take some getting used to, but there's a payoff there. Just
don't insist that everything be immutable. Your colleagues will hate you.

Note that if your object must return references to data, those are often
mutable. However, you can declare those as immutable, too.


```perl
package Some::Class {
    use Const::Fast 'const';

    # set up data here

    sub get_data_structure {
        my $self = shift;
        const my %hash => (
            name     => $self->name,
            giggity  => $self->_something_else,
        );
        return \%hash;
    }
}
```

In the above, the `get_data_structure` method returns an immutable data
structure. Attempts to access unknown hash keys or change any of the values is a
fatal error (use `exists` to test hash keys, of course). Some people call it
overkill.  Others call it safety. Your mileage may vary.

If you prefer, you can deeply clone the data structure before returning it. By
presenting a copy, different consumers calling that method will always have the
same results, but if the returned reference itself is shared, you could have
issues. That being said, this is an issue with any large-scale code, not just
OOP.

## Small Interfaces and Encapsulation

The interface that your class presents is your "contract" with everyone who uses
your class. You should design that interface with care, but you shouldn't expose
what you don't need to. Using one of my "go to" examples of Corinna code that
will be available in upcoming releases (but not in the immediate future), here's
an LRU (least recently used) cache:

```perl
class Cache::LRU :version(v0.1.0) {
    use Hash::Ordered;

    field $cache                   { Hash::Ordered->new };
    field $max_size :param :reader { 20 };

    method set ( $key, $value ) {
        if ( $cache->exists($key) ) {
            $cache->delete($key);
        }
        elsif ( $cache->keys > $max_size ) {
            $cache->shift;
        }
        $cache->set( $key, $value );  # add to front
    }

    method get ($key) {
        if ( $cache>exists($key) ) {
            my $value = $cache->get($key);
            $self->set( $key, $value ); # add to front
            return $value;
        }
        return;
    }
}
```

With the popular Moose OOP system for Perl, that would look something like this
(skipping the sub bodies):

```perl
package Cache::LRU {
    use Moose;
    use Hash::Ordered;
    use namespace::autoclean;

    has '_cache' => (
        is       => 'ro',
        init_arg => undef,
        default  => sub { Hash::Ordered->new },
    );

    has 'max_size' => ( is => 'ro', default => 20 );

    sub set {
		...
    }

    sub get {
		...
    }

    __PACKAGE__->meta->make_immutable;
}

```

For raw Perl, it might even look like this:

```perl
package Cache::LRU;

use strict;
use warnings;
use Hash::Ordered;

sub new {
    my ( $class, $max_size ) = @_;
    $max_size //= 20;
    return bless {
        max_size => $max_size,
        _cache   => Hash::Ordered->new,
    }, $class;
}

# more code here
```

For both Moose and core Perl, it's hard to encapsulate your objects and minimize
your interface. For both of those, you can call `$object->{_cache}` to get the
underlying cache. For Moose, you can also call `$object->_cache` (it's very
cumbersome in Moose or Moo to not offer private methods for private data).  This
means that you have exposed that data, no matter how nicely you've asked people
to "stay out of the kitchen." This means that later on, if you want to switch
your internal cache to use Redis, SQLite, you can easily break the code of
others who are relying on it.

We almost always see `$object->_private_method` or `$object->{private_data}` in
client codebases and that's one of the first things we try to fix, if we have
time. As a class author, you need to know you can safely change the internals of
your object.

### Recommendation

Keep your classes as small as you can and stop making accessors public by
default. For now, this means prefixing methods with an underscore to make them
"private by convention." With Corinna, you simply don't provide `:reader` or
`:writer` attributes:

```perl
class Cache::LRU :version(v0.1.0) {
    use Hash::Ordered;

    field $cache                   { Hash::Ordered->new };
    field $max_size :param :reader { 20 };
    ...
```

In the above, you can read (but not write) the max size, but there's no direct
access possible to the `$cache` (this will be possible via the MOP, the
meta-object protocol, but we want violating encapsulation to be a natural
default).

> Note: some Perl developers still use "inside-out" objects to enforce
> encapsulation. The CPAN has
> [Object::InsideOut](https://metacpan.org/pod/Object::InsideOut) and
> [Class::InsideOut](https://metacpan.org/pod/Class::InsideOut), amongst others.
> While it's easy to use instances of these classes, they were cumbersome to write
> and sometimes buggy.

## Type Library

As systems grow, it's very easy to have this problem:

```perl
sub get_part_by_id ($self, $id) {
    return $self->_inventory_schema->resultset('Part')->find($id);
}
```

Most of the time that works, but sometimes you get no result. What happened?
Maybe your primary key is a UUID but you've supplied an integer? Oops. So now
you have to rewrite that:


```perl
sub get_part_by_id ($self, $id) {
    unless ( $id =~ qr/^[0-9a-f]{8}(?:-[0-9a-f]{4}){2}-[0-9a-f]{12}$/is ) {
        croak("ID ($id) does not look like a UUID.");
    }
    return $self->_inventory_schema->resultset('Part')->find($id);
}
```

Do you really want to write that? Do you really want to debug that? (I
deliberately added a bug). If you use UUIDs frequently, you don't want to write
that again.

If you've used Moose, you know how easy it is to use type constraints:

```perl
has 'order_items' => (
    is     => 'ro',
    isa    => 'ArrayRef[HashRef]',
    writer => '_set_order_items',
);
```

Of course, if you spell the `isa` as `ArrayRef[HasRef]`, you won't find out
until runtime that you've misspelled it. For these and other situations, just
create a type library as a centralized place to put your types and share them
across your codebase as needed. If there's too much code, focus on critical
paths first.

### Recommendation

Creating a type library for the first time can be daunting. Here's a simple one,
based on the excellent [Type::Tiny](https://metacpan.org/pod/Type::Tiny) by Toby
Inkster. It will cover most of your basic needs and you can extend it later with
custom types, if needed.

```perl
package My::Personal::Types;

use strict;
use warnings;
use Type::Library -base;
use Type::Utils -all;
use Type::Params; # this gets us compile and compile_named

our @EXPORT_OK;

BEGIN {
    # this gets us most of our types
    extends qw(
      Types::Standard
      Types::Common::Numeric
      Types::Common::String
      Types::UUID
    );
    push @EXPORT_OK => (
        'compile',
        'compile_named',
    );
}

1;
```

Using it is simple.


```perl
use My::Personal::Types qw(compile UUID);
sub get_part_by_id ($self, $id) {
    state $check = compile(UUID);
    ($id) = $check->($id);
    return $self->_inventory_schema->resultset('Part')->find($id);
}
```

And in Moose, use these constraints to turn misspelled types into
compile time failures (and to get a much richer set of allowed types):

```perl
use My::Personal::Types qw(ArrayRef HashRef);
has 'order_items' => (
    is     => 'ro',
    isa    => ArrayRef [HashRef],
    writer => '_set_order_items',
);
```

Despite the `Type::Tiny` name, [the manual is quite
extensive](https://metacpan.org/dist/Type-Tiny/view/lib/Type/Tiny/Manual.pod).
Go there for more information.

## Subclassing

A subclass of a class is intended to be a more specialized version of that
class. A `Car isa Vehicle`, or a `Human isa Mammal`. However, it's easy to get
this wrong under the pressure of deadlines, complex code bases, or just plain
not paying attention. Is `Item isa Product` correct? Or is `Product isa Item`
more correct?

Ultimately, the problem manifests itself in what I call the "person/invoice
problem": `Person isa Invoice`. That makes absolutely no sense, but _your
software doesn't know that_. Your software only does what you tell it to do. It
can't evaluate semantics (at least, not yet), and if you write code that runs,
but doesn't make sense, that's too bad.

In fact, inheritance is so problematic that some OOP languages disallow it
altogether, favoring composition instead. Some only allow single inheritance,
but provide alternatives (mixins, interfaces, traits, etc.). As a general rule,
we recommend you use roles instead of parent classes:

* [Role::Tiny](https://metacpan.org/pod/Role::Tiny) (for any OO code)
* [Moose::Role](https://metacpan.org/pod/Moose::Role) (for Moose)
* [Moo::Role](https://metacpan.org/pod/Moo::Role) (for Moo)

There's also my own [Role::Basic](https://metacpan.org/pod/Role::Basic) which
can be used where `Role::Tiny` is appropriate, but [the philosophy of that
module is
different](https://metacpan.org/dist/Role-Basic/view/lib/Role/Basic/Philosophy.pod)
and presents somewhat different features.

Sometimes inheritance is the right thing to do. For example, in the
[Test::Class::Moose](https://metacpan.org/pod/Test::Class::Moose) xUnit
framework, we have "test control methods" which run code before the class is
instantiated, before each method is run, after each method is run, and after the
test class has finished running. A `test_setup` method might look like this:

```perl
sub test_setup {
   my $test = shift;
   $test->next::method;
   $test->load_fixtures(qw/Customer Orders/);
}
```

In the above example, the `$test->next::method` is used to call the parent
`test_setup` to ensure that all setup is ready before you try to call your
setup. In fact, you might have your `test_setup` call a parent `test_setup`
which in turns calls _its_ parent `test_setup`. This is common in xUnit testing
and the order in which events fire is important. With roles, this is often done
with method modifiers, but the order in which they fire is often dependent on
their load order and that is *not* guaranteed. If you find yourself using lots
of method modifiers in roles, you might want to think about inheritance to
ensure that you have complete control over the sequencing of commands.

### Recommendation

We should prefer composition or roles over inheritance. Composition is good when
you clearly have an object to delegate to. Roles are good when you have some
behavior which might apply to unrelated classes (such as serialization to JSON
or XML).

There's a lot more we could say about roles, but a full tutorial is beyond the
scope of this article.

## Performance

Don't stress about performance, really. It's not the code. It's the database. Or
it's the network. Or it's disk I/O. Or, or, or ...

Steve McConnell, in his fantastic book Code Complete, 2nd edition, writes:

> It’s almost impossible to identify performance bottlenecks before a program is
> working completely. Programmers are very bad at guessing which four percent of
> the code accounts for 50 percent of the execution time, and so programmers who
> optimize as they go will, on average, spend 96 percent of their time
> optimizing code that doesn't need to be optimized. That leaves little time to
> optimize the four percent that really counts.

Unless you know, at design time, you'll have performance critical code (don't
write ray-tracing software in Perl, folks!), design a great system and worry
about performance only when it's proven to be a real problem.
[Devel::NYTProf](https://metacpan.org/pod/Devel::NYTProf) is your friend here.
Be aware that benchmarking can be an arcane art.

But when we talk about performance, whose performance are we talking about? The
software or the software developer? Here's a little benchmark for you:

```perl
#!/usr/bin/env perl

use strict;
use warnings;
use Benchmark 'cmpthese';

sub use_a_loop {
    my @numbers;
    foreach my $i ( 0 .. 9 ) {
        $numbers[$i] = $i / ( $i + 1 );
    }
    return \@numbers;
}

sub direct_assignment {
    my @numbers;
    $numbers[0] = 0 / 1;
    $numbers[1] = 1 / 2;
    $numbers[2] = 2 / 3;
    $numbers[3] = 3 / 4;
    $numbers[4] = 4 / 5;
    $numbers[5] = 5 / 6;
    $numbers[6] = 6 / 7;
    $numbers[7] = 7 / 8;
    $numbers[8] = 8 / 9;
    $numbers[9] = 9 / 10;
    return \@numbers;
}

cmpthese(
    1_000_000,
    {
        'use_a_loop'        => \&use_a_loop,
        'direct_assignment' => \&direct_assignment,
    }
);
```

Do you think the loop or the direct assignment is faster? Do you really care?
Well, it should be pretty clear that the loop is much easier to maintain. The
direct assignment, however ...

```
                       Rate        use_a_loop direct_assignment
use_a_loop         970874/s                --              -50%
direct_assignment 1923077/s               98%                --
```

Whoa! Directly assigning the data is twice as fast as the loop! If something
like that is at the bottom of a tight loop and benchmarking shows that it's a
performance issue, then yes, switching from a loop to direct assignment might be
an idea, but that would kill _developer_ performance when it comes to
maintaining that code. If you must do that, document it carefully, perhaps
including a snippet of the code that this replaces.

### Recommendation

Design the system well and don't worry about performance while building it.
Doing so runs the risk of optimizing code that doesn't need to be optimized and
possibly makes the code harder to maintain, raising long-term costs.

Instead, if your code is suffering performance issues, benchmark your code and
find out where the real problems are. Here's a video of Tim Bunce explaining how
to profile your code:

[% Ovid.youtube('SDWoCQf53Ck') %]

# Problems

## Too many responsibilities

## Immutable

## accessors for attributes

## namespace::autoclean and make_immutable

## Consistent return types

Return empty types [] {}

## Strict constructor

## Small interfaces

## Roles
    modifiers
    abstract classes

# Dr. Frankenstein

If you've gotten this far, congrats! One thing very helpful with OO code is to
develop a set of guidelines on how you'll build OO code and stick to it. We're
going to be Dr. Frankenstein and build our own object system out of the parts we
have laying around. By ensuring everyone uses this object system, we can have
greater consistency in our code.

Let's pretend you've settled on the Moose OOP system as the basis of your own.
You'd like to ensure several things are true (I'm not saying these are the best 
defaults, but this can get you started):

* Unknown arguments to the constructor are fatal
* It should be easier to see which attributes are or are not required in the
constructor
* `namespace::autoclean` must always be used
* You want signatures and types
* The `Carp` module's `carp`, `croak`, and `confess` functions should always be
present

For this, you've decided that `param` should replace `has` if the parameter is
required in the constructor, and `field` should replace `has` if the parameter
is not allowed in the constructor. Let's use
[Moose::Exporter](https://metacpan.org/pod/Moose::Exporter) to set this up.

```perl
package My::Personal::Moose;
package MooseX::Fields;

use 5.22.0;
use Moose                     ();
use MooseX::StrictConstructor ();
use Moose::Exporter;
use mro                  ();
use feature              ();
use namespace::autoclean ();
use Import::Into;
use Carp qw/carp croak confess/;

Moose::Exporter->setup_import_methods(
    with_meta => [ 'field', 'param' ],
    as_is     => [ \&carp, \&croak, \&confess ],
    also      => ['Moose'],
);

sub init_meta {
    my ( $class, @args ) = @_;
    my %params    = @args;
    my $for_class = $params{for_class};
    Moose->init_meta(@args);
    MooseX::StrictConstructor->import( { into => $for_class } );
    warnings->unimport('experimental::signatures');
    feature->import(qw/signatures :5.22/);
    namespace::autoclean->import::into($for_class);

    # If we never use multiple inheritance, this should not be needed.
    mro::set_mro( scalar caller(), 'c3' );
}

sub field {
    my ( $meta, $name, %opts ) = @_;

    $opts{is} //= 'ro';

    # "has [@attributes]" versus "has $attribute"
    foreach my $attr ( 'ARRAY' eq ref $name ? @$name : $name ) {
        my %options = %opts;    # copy each time to avoid overwriting
        $options{init_arg} = undef;
        $meta->add_attribute( $attr, %options );
    }
}

sub param {
    my ( $meta, $name, %opts ) = @_;

    $opts{is}       //= 'ro';
    $opts{required} //= 1;

    # "has [@attributes]" versus "has $attribute"
    foreach my $attr ( 'ARRAY' eq ref $name ? @$name : $name ) {
        my %options = %opts;    # copy each time to avoid overwriting
        $options{init_arg} //= $attr;
        $meta->add_attribute( $attr, %options );
    }
}

1;
```

With that, and the `My::Personal::Types` above, here's a (silly) example of how
to use this:

```perl
#!/usr/bin/env perl

use lib 'lib';
use Test::Most;

package My::Names {
    use v5.22.0;
    use My::Personal::Moose;
    use My::Personal::Types
      qw(compile Num NonEmptyStr Str PositiveInt ArrayRef);
    use List::Util 'sum'; # this gets removed my namespace::autoclean

    param _name   => ( isa => NonEmptyStr, init_arg => 'name' );
    param title   => ( isa => Str,         required => 0 );
    field created => ( isa => PositiveInt, default  => sub { time } );

    sub name ($self) {
        my $title = $self->title;
        my $name  = $self->_name;
        return $title ? "$title $name" : $name;
    }

    sub add ( $self, $args ) {
        state $check = compile( ArrayRef [Num] );
        ($args) = $check->($args);
        carp("no numbers supplied to add()") unless $args->@*;
        return sum( $args->@* );
    }

    __PACKAGE__->meta->make_immutable;
}

my $person = My::Names->new( name => 'Ovid', );
is $person->name, 'Ovid', 'name should be correct';
ok !defined $person->title, '... and no title';
cmp_ok $person->created, '>', 0, '... and a sane default for created';
ok !$person->can('sum'), 'subroutines have been removed from the namespace';
is $person->add( [qw/1 3 5 6/] ), 15, 'Our add() method should work';
throws_ok { My::Names->new( name => 'Ovid', created => 1 ) }
'Moose::Exception',
  'Attributes not defined as `param` are illegal in the constructor';

my $doctor = My::Names->new( name => 'Smith', title => 'Dr.' );
is $doctor->name,        'Dr. Smith', 'Titles should show up correctly';
cmp_ok $doctor->created, '>=',        $person->created,
  '... and their created date should be correct';

done_testing;
```

[%- END %]
