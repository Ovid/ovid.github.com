<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Themed Maze Escape Game</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        #container {
            display: flex;
            width: 95%;
            height: 95vh;
            gap: 20px;
        }
        #sidebar {
            flex: 0 0 250px;
            display: flex;
            flex-direction: column;
            max-height: 100%;
            overflow-y: auto;
        }
        #gameCanvas {
            border: 1px solid #000;
            max-width: calc(100% - 270px);
            height: 100%;
            object-fit: contain;
        }
        #hud, #instructions {
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: clamp(14px, 2vw, 16px);
        }
        h1 {
            font-size: clamp(20px, 3vw, 24px);
            margin: 0 0 15px 0;
        }
        #theme {
            font-weight: bold;
            color: #444;
        }
        @media (max-width: 768px) {
            #container {
                flex-direction: column;
                height: auto;
            }
            #sidebar {
                flex: 0 0 auto;
                width: 100%;
                max-width: 100%;
            }
            #gameCanvas {
                max-width: 100%;
                height: 60vh;
            }
        }
        #levelAnnouncement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 1s;
            pointer-events: none;
            z-index: 100;
        }

        #levelAnnouncement.visible {
            opacity: 1;
        }

        #levelName {
            font-size: 36px;
            margin-top: 10px;
        }

    #difficultySelect {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: 
            linear-gradient(transparent 50%, rgba(0, 0, 0, 0.9) 50%),
            linear-gradient(90deg, #000046, #1CB5E0);
        background-size: 4px 4px, 100% 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        animation: scanline 10s linear infinite;
    }

    @keyframes scanline {
        0% {
            background-position: 0 0;
        }
        100% {
            background-position: 0 100%;
        }
    }

    #difficultySelect h2 {
        font-family: 'courier';
        color: #fff;
        font-size: 32px;
        margin-bottom: 50px;
        text-align: center;
        text-shadow: 
            0 0 10px rgba(255,255,255,0.8),
            0 0 20px rgba(255,255,255,0.8),
            0 0 30px rgba(255,255,255,0.8),
            4px 4px 0 #000;
        animation: glow 2s ease-in-out infinite alternate;
    }

    @keyframes glow {
        from {
            text-shadow: 
                0 0 10px rgba(255,255,255,0.8),
                0 0 20px rgba(255,255,255,0.8),
                0 0 30px rgba(255,255,255,0.8),
                4px 4px 0 #000;
        }
        to {
            text-shadow: 
                0 0 20px rgba(255,255,255,0.8),
                0 0 30px rgba(255,255,255,0.8),
                0 0 40px rgba(255,255,255,0.8),
                4px 4px 0 #000;
        }
    }

    .difficulty-option {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-bottom: 30px;
        width: 300px;
    }

    .difficulty-btn {
        width: 100%;
        padding: 15px;
        font-family: 'courier';
        font-size: 20px;
        border: 4px solid #fff;
        border-radius: 0;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        position: relative;
        margin-bottom: 15px;
        color: white;
        text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.5);
        box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.5);
    }
    
    .difficulty-btn::before {
        display: none;
    }
    
    .difficulty-btn:hover {
        transform: translate(2px, 2px);
        box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
    }
    
    #easy {
        background-color: #00ff00;
        border-color: #00cc00;
    }
    
    #medium {
        background-color: #ffff00;
        border-color: #cccc00;
    }
    
    #hard {
        background-color: #ff0000;
        border-color: #cc0000;
    }

    .difficulty-btn:hover {
        transform: translate(4px, 4px);
    }

    .difficulty-btn:hover::after {
        transform: translate(-4px, -4px);
    }

    .difficulty-desc {
        font-family: 'courier';
        color: #fff;
        font-size: 12px;
        text-align: center;
        opacity: 0.8;
        line-height: 1.5;
        text-shadow: 2px 2px #000;
    }


    /* Add scanlines effect */
    #difficultySelect::after {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
            0deg,
            rgba(0, 0, 0, 0.1),
            rgba(0, 0, 0, 0.1) 1px,
            transparent 1px,
            transparent 2px
        );
        pointer-events: none;
    }

    /* Add blinking effect to title */
    #difficultySelect h2::after {
        content: '_';
        animation: blink 1s step-end infinite;
    }

    @keyframes blink {
        50% { opacity: 0; }
    }
    </style>
</head>
<body>
    <div id="difficultySelect">
        <h2><a name="a-nameselect-difficulty"></a><a name="select-difficulty"></a>Select Difficulty</h2>
        <div class="difficulty-option">
            <button id="easy" class="difficulty-btn">Easy</button>
            <div class="difficulty-desc">Slower monsters, 3 teleports to start</div>
        </div>
        <div class="difficulty-option">
            <button id="medium" class="difficulty-btn">Medium</button>
            <div class="difficulty-desc">Normal monsters, 2 teleports to start</div>
        </div>
        <div class="difficulty-option">
            <button id="hard" class="difficulty-btn">Hard</button>
            <div class="difficulty-desc">Fast monsters, 1 teleport to start</div>
        </div>
    </div>
    <div id="container">
        <div id="sidebar">
            <h1><a name="a-namea-nameescape"></a><a name="a-nameescape"></a><a name="escape"></a>Escape!</h1>
            <div id="hud">
                <div>Level: <span id="level">1</span></div>
                <div>Theme: <span id="theme">Forest</span></div>
                <div>Difficulty: <span id="currentDifficulty">-</span></div>
                <div>Teleports: <span id="teleports">1</span></div>
                <div id="pausedStatus">Paused: <span id="paused">Yes</span></div>
            </div>
            <div id="instructions">
                <p>Instructions:</p>
                <ul>
                    <li>Use arrow keys to move.</li>
                    <li>Press "T" to teleport.</li>
                    <li>Press "Space" to pause/unpause.</li>
                    <li>Escape the maze to advance to the next level.</li>
                    <li>Earn 1 teleport per level.</li>
                    <li>Unused teleports carry over to next level.</li>
                    <li>Reach level 6 to win!</li>
                </ul>
                <p>This game was primarily built as an experiment with Claude
                3.5 Sonnet, and ChatGPT 4.</p>

                <p><a href="/"><strong>Return to the site.</strong></a></p>
            </div>
        </div>
        <div id="levelAnnouncement">
            Level <span id="announcementLevel">1</span>
            <div id="levelName">Forest</div>
            <div id="announcementDifficulty" style="font-size: 24px; margin-top: 10px;"></div>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        const levelAnnouncement      = document.getElementById('levelAnnouncement');
        const announcementLevel      = document.getElementById('announcementLevel');
        const levelName              = document.getElementById('levelName');
        const canvas                 = document.getElementById('gameCanvas');
        const hudLevel               = document.getElementById('level');
        const hudTheme               = document.getElementById('theme');
        const hudTeleports           = document.getElementById('teleports');
        const hudPaused              = document.getElementById('paused');
        const pausedStatus           = document.getElementById('pausedStatus');
        const ctx                    = canvas.getContext('2d');
        const hudDifficulty          = document.getElementById('currentDifficulty');
        const announcementDifficulty = document.getElementById('announcementDifficulty');
		const max_level              = 6;
        const door                   = 2;

        let CELL_SIZE = 40;
        let ROWS      = 15;
        let COLS      = 20;

        const THEMES = {
            1: {
                name: 'Forest',
                wallColor: '#2d5a27',      // Dark green
                wallStroke: '#3a7634',     // Lighter green
                floorColor: '#90a955',     // Light moss green
                doorColor: '#8b4513',      // Brown
                doorDetail: '#a0522d',     // Lighter brown
                monsterColors: ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#88d8b0']  // Forest creatures
            },
            2: {
                name: 'Dungeon',
                wallColor: '#4a4e69',      // Dark stone
                wallStroke: '#686d8c',     // Lighter stone
                floorColor: '#22223b',     // Dark floor
                doorColor: '#9b2226',      // Dark red
                doorDetail: '#ae2012',     // Lighter red
                monsterColors: ['#800e13', '#9b2226', '#ae2012', '#bb3e03', '#ca6702']  // Fire tones
            },
            3: {
                name: 'Space Station',
                wallColor: '#2b2d42',      // Dark blue
                wallStroke: '#8d99ae',     // Metal grey
                floorColor: '#14213d',     // Deep space blue
                doorColor: '#fca311',      // Warning yellow
                doorDetail: '#ffba08',     // Bright yellow
                monsterColors: ['#e63946', '#457b9d', '#a8dadc', '#f1faee', '#dad7cd']  // Space tones
            },
            4: {
                name: 'Ice Cave',
                wallColor: '#a8dadc',      // Ice blue
                wallStroke: '#457b9d',     // Darker ice blue
                floorColor: '#f1faee',     // Snow white
                doorColor: '#48cae4',      // Bright ice
                doorDetail: '#90e0ef',     // Light ice
                monsterColors: ['#caf0f8', '#ade8f4', '#90e0ef', '#48cae4', '#00b4d8']  // Ice tones
            },
            5: {
                name: 'Volcano',
                wallColor: '#7f5539',      // Dark brown
                wallStroke: '#9c6644',     // Brown
                floorColor: '#bc6c25',     // Lighter brown
                doorColor: '#dc2f02',      // Bright red
                doorDetail: '#e85d04',     // Orange
                monsterColors: ['#dc2f02', '#e85d04', '#f48c06', '#faa307', '#ffba08']  // Lava tones
            }
        };

        function getTheme(level) {
            return THEMES[((level - 1) % 5) + 1];
        }

        let playerDirection    = 'right';
        let isPaused           = true;
        let currentLevel       = 1;
        let player             = { x: 1, y: 1 };
        let monsters           = [];
        let maze               = [];
        let stairs             = { x: 0, y: 0 };
        let teleports          = 1;
        let monsterMoveCounter = 0;
        let gameStarted        = false;
        let difficulty         = 'medium';
        let monsterSpeed       = 10; // Default speed (medium)
        let startingTeleports  = 2; // Default teleports (medium)
		let playerPixelPos = { x: CELL_SIZE, y: CELL_SIZE };
		let playerTargetPos = { x: CELL_SIZE, y: CELL_SIZE };
		let monstersPixelPos = [];
		let monstersTargetPos = [];
		const MOVEMENT_SPEED = 5; 

        document.getElementById('easy').addEventListener('click', () => startGame('easy'));
        document.getElementById('medium').addEventListener('click', () => startGame('medium'));
        document.getElementById('hard').addEventListener('click', () => startGame('hard'));

        function startGame(selectedDifficulty) {
            difficulty = selectedDifficulty;

            switch(difficulty) {
                case 'easy':
                    monsterSpeed      = 15;
                    startingTeleports = 3;
                    break;
                case 'medium':
                    monsterSpeed      = 10;
                    startingTeleports = 2;
                    break;
                case 'hard':
                    monsterSpeed      = 6;
                    startingTeleports = 1;
                    break;
            }

            document.getElementById('difficultySelect').style.display = 'none';
            gameStarted  = true;
            currentLevel = 1;
            teleports    = startingTeleports;
            monsters     = [];  // Ensure monsters array is clear
            initGame();
        }

        function initGame() {
            // Generate new maze
            maze = generateMaze(ROWS, COLS);

            // Reset player position
            player = { x: 1, y: 1 };

            // Clear and regenerate monsters
            monsters = [];

            // Only add monsters after level 1
            if (currentLevel > 1) {
                const minDistance = Math.floor(Math.min(COLS, ROWS) / 3);
                const numMonsters = Math.min(currentLevel - 1, 5);

                for (let i = 0; i < numMonsters; i++) {
                    let monsterX, monsterY;
                    do {
                        monsterX = Math.floor(Math.random() * (COLS - 2)) + 1;
                        monsterY = Math.floor(Math.random() * (ROWS - 2)) + 1;
                    } while (
                        maze[monsterY][monsterX] !== 0 ||
                        Math.abs(monsterX - player.x) < minDistance ||
                        Math.abs(monsterY - player.y) < minDistance
                    );
                    monsters.push({ x: monsterX, y: monsterY });
                }
            }

            // Set exit position
            stairs = { x: COLS - 2, y: ROWS - 2 };
            maze[stairs.y][stairs.x] = 2;

            // Handle teleports
            if (gameStarted) {
                teleports += 1;
            } else {
                teleports = startingTeleports;
            }

            updateHUD();

            // Show level announcement
            announcementLevel.textContent = currentLevel;
            levelName.textContent = getTheme(currentLevel).name;
            announcementDifficulty.textContent =
                `Difficulty: ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`;
            levelAnnouncement.classList.add('visible');

            setTimeout(() => {
                levelAnnouncement.classList.remove('visible');
            }, 3000);
			playerPixelPos = {
				x: player.x * CELL_SIZE,
				y: player.y * CELL_SIZE
			};
			playerTargetPos = { ...playerPixelPos };

			// Initialize monster pixel positions
			monstersPixelPos = monsters.map(m => ({
				x: m.x * CELL_SIZE,
				y: m.y * CELL_SIZE
			}));
			monstersTargetPos = monstersPixelPos.map(pos => ({ ...pos }));
        }

        function generateMaze(rows, cols) {
            const maze = Array(rows).fill().map(() => Array(cols).fill(1));

            function isValid(x, y) {
                return x >= 0 && x < cols && y >= 0 && y < rows;
            }

            function carvePath(x, y) {
                const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]].sort(() => Math.random() - 0.5);

                for (const [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;

                    if (isValid(nx, ny) && maze[ny][nx] === 1) {
                        maze[y + dy/2][x + dx/2] = 0;
                        maze[ny][nx] = 0;
                        carvePath(nx, ny);
                    }
                }
            }

            carvePath(1, 1);

            for (let i = 0; i < rows * cols / 50; i++) {
                const x = Math.floor(Math.random() * (cols - 2)) + 1;
                const y = Math.floor(Math.random() * (rows - 2)) + 1;
                if (maze[y][x] === 1) {
                    maze[y][x] = 0;
                    carvePath(x, y);
                }
            }

            maze[1][1] = 0;
            maze[rows - 2][cols - 2] = 0;

            for (let i = 0; i < Math.max(rows, cols) / 8; i++) {
                const x = Math.floor(Math.random() * (cols - 3)) + 1;
                const y = Math.floor(Math.random() * (rows - 3)) + 1;
                for (let dy = 0; dy <= 1; dy++) {
                    for (let dx = 0; dx <= 1; dx++) {
                        maze[y + dy][x + dx] = 0;
                    }
                }
            }

            return maze;
        }

        function drawMaze() {
            const theme = getTheme(currentLevel);
            ctx.fillStyle = theme.floorColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = theme.wallColor;
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        ctx.strokeStyle = theme.wallStroke;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    } else if (maze[y][x] === door) {
                        // Draw themed exit door
                        ctx.fillStyle = theme.doorColor;
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        ctx.fillStyle = theme.doorDetail;
                        ctx.fillRect(x * CELL_SIZE + CELL_SIZE * 0.1, y * CELL_SIZE, CELL_SIZE * 0.8, CELL_SIZE);
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(x * CELL_SIZE + CELL_SIZE * 0.75, y * CELL_SIZE + CELL_SIZE * 0.5, CELL_SIZE * 0.05, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function drawPlayer() {
            const x = playerPixelPos.x + CELL_SIZE / 2;
            const y = playerPixelPos.y + CELL_SIZE / 2;
            const radius = CELL_SIZE / 3;
            const mouthAngle = Math.PI / 4;
        
            let startAngle, endAngle;
            let eyeXOffset, eyeYOffset;
        
            switch (playerDirection) {
                case 'right':
                    startAngle = mouthAngle;
                    endAngle = -mouthAngle;
                    eyeXOffset = radius / 3;
                    eyeYOffset = -radius / 1.5;
                    break;
                case 'left':
                    startAngle = Math.PI + mouthAngle;
                    endAngle = Math.PI - mouthAngle;
                    eyeXOffset = -radius / 3;
                    eyeYOffset = -radius / 1.5;
                    break;
                case 'up':
                    startAngle = -Math.PI / 2 + mouthAngle;
                    endAngle = -Math.PI / 2 - mouthAngle;
                    eyeXOffset = -radius / 2.5;
                    eyeYOffset = -radius / 5.8;
                    break;
                case 'down':
                    startAngle = Math.PI / 2 + mouthAngle;
                    endAngle = Math.PI / 2 - mouthAngle;
                    eyeXOffset = -radius / 2.5;
                    eyeYOffset = radius / 5.8;
                    break;
            }
        
            ctx.fillStyle = '#ff0';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.arc(x, y, radius, startAngle, endAngle, false);
            ctx.lineTo(x, y);
            ctx.fill();
        
            ctx.fillStyle = '#00f';
            ctx.beginPath();
            ctx.arc(x + eyeXOffset, y + eyeYOffset, radius / 6, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Update drawMonsters() to use pixel positions
        function drawMonsters() {
            const theme = getTheme(currentLevel);
            const ghostColors = theme.monsterColors;
        
            for (let i = 0; i < monsters.length; i++) {
                const x = monstersPixelPos[i].x + CELL_SIZE / 2;
                const y = monstersPixelPos[i].y + CELL_SIZE / 2;
                const color = ghostColors[i % ghostColors.length];
                const radius = CELL_SIZE / 3;
        
                // Ghost body
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y - radius / 3, radius, Math.PI, 0, false);
                ctx.lineTo(x + radius, y + radius / 3);
                ctx.lineTo(x - radius, y + radius / 3);
                ctx.closePath();
                ctx.fill();
        
                // Ghost waves
                ctx.beginPath();
                for (let j = -1; j <= 1; j++) {
                    ctx.arc(x + (j * radius / 3), y + radius / 3, radius / 3, 0, Math.PI, true);
                }
                ctx.fill();
        
                // Eyes
                ctx.fillStyle = '#fff';
                const eyeRadius = radius / 5;
                ctx.beginPath();
                ctx.arc(x - radius / 2.5, y - radius / 5, eyeRadius, 0, Math.PI * 2);
                ctx.arc(x + radius / 2.5, y - radius / 5, eyeRadius, 0, Math.PI * 2);
                ctx.fill();
        
                // Pupils
                ctx.fillStyle = '#000';
                const pupilRadius = radius / 10;
                ctx.beginPath();
                ctx.arc(x - radius / 2.5, y - radius / 5, pupilRadius, 0, Math.PI * 2);
                ctx.arc(x + radius / 2.5, y - radius / 5, pupilRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Add a new function to update positions
        function updatePositions() {
            if (isPaused) return;
        
            // Update player position
            const dx = playerTargetPos.x - playerPixelPos.x;
            const dy = playerTargetPos.y - playerPixelPos.y;
            
            if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                playerPixelPos.x += Math.sign(dx) * Math.min(Math.abs(dx), MOVEMENT_SPEED);
                playerPixelPos.y += Math.sign(dy) * Math.min(Math.abs(dy), MOVEMENT_SPEED);
            } else {
                playerPixelPos = { ...playerTargetPos };
            }
        
            // Update monster positions
            for (let i = 0; i < monsters.length; i++) {
                const dx = monstersTargetPos[i].x - monstersPixelPos[i].x;
                const dy = monstersTargetPos[i].y - monstersPixelPos[i].y;
                
                if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                    monstersPixelPos[i].x += Math.sign(dx) * Math.min(Math.abs(dx), MOVEMENT_SPEED);
                    monstersPixelPos[i].y += Math.sign(dy) * Math.min(Math.abs(dy), MOVEMENT_SPEED);
                } else {
                    monstersPixelPos[i] = { ...monstersTargetPos[i] };
                }
            }
        }

        function moveMonsters() {
            if (isPaused) return;
            monsterMoveCounter++;
            if (monsterMoveCounter % monsterSpeed !== 0) return;
        
            // Only move monsters if they've reached their target positions
            const allMonstersAtTarget = monsters.every((m, i) => 
                Math.abs(monstersPixelPos[i].x - monstersTargetPos[i].x) < 0.1 && 
                Math.abs(monstersPixelPos[i].y - monstersTargetPos[i].y) < 0.1
            );
        
            if (!allMonstersAtTarget) return;
        
            const newPositions = [];
        
            for (const monster of monsters) {
                const possibleMoves = [];
        
                if (monster.x > 0 && maze[monster.y][monster.x - 1] !== 1)
                    possibleMoves.push({ x: monster.x - 1, y: monster.y });
                if (monster.x < COLS - 1 && maze[monster.y][monster.x + 1] !== 1)
                    possibleMoves.push({ x: monster.x + 1, y: monster.y });
                if (monster.y > 0 && maze[monster.y - 1][monster.x] !== 1)
                    possibleMoves.push({ x: monster.x, y: monster.y - 1 });
                if (monster.y < ROWS - 1 && maze[monster.y + 1][monster.x] !== 1)
                    possibleMoves.push({ x: monster.x, y: monster.y + 1 });
        
                possibleMoves.sort((a, b) => {
                    const distA = Math.abs(a.x - player.x) + Math.abs(a.y - player.y);
                    const distB = Math.abs(b.x - player.x) + Math.abs(b.y - player.y);
                    return distA - distB;
                });
        
                if (possibleMoves.length > 0) {
                    newPositions.push({ x: possibleMoves[0].x, y: possibleMoves[0].y });
                } else {
                    newPositions.push({ x: monster.x, y: monster.y });
                }
            }
        
            const positionSet = new Set();
            let conflict = false;
            for (const pos of newPositions) {
                const posKey = `${pos.x},${pos.y}`;
                if (positionSet.has(posKey)) {
                    conflict = true;
                    break;
                }
                positionSet.add(posKey);
            }
        
            if (!conflict) {
                for (let i = 0; i < monsters.length; i++) {
                    monsters[i].x = newPositions[i].x;
                    monsters[i].y = newPositions[i].y;
                    monstersTargetPos[i] = {
                        x: monsters[i].x * CELL_SIZE,
                        y: monsters[i].y * CELL_SIZE
                    };
                }
            }
        }

        function checkCollision() {
            for (const monster of monsters) {
                if (monster.x === player.x && monster.y === player.y) {
                    alert(`Game Over! You were caught by a monster.\nDifficulty: ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`);
                    showDifficultySelect();
                    return;
                }
            }
        }

        function showDifficultySelect() {
            document.getElementById('difficultySelect').style.display = 'flex';
            gameStarted = false;
            currentLevel = 1;
            teleports = 1;
            updateHUD();
        }

        function updateHUD() {
            hudLevel.textContent = currentLevel;
            hudTheme.textContent = getTheme(currentLevel).name;
            hudTeleports.textContent = teleports;
            hudPaused.textContent = isPaused ? "Yes" : "No";
            hudDifficulty.textContent = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);

            if (isPaused) {
                pausedStatus.style.color = 'white';
                pausedStatus.style.backgroundColor = 'black';
            } else {
                pausedStatus.style.color = '';
                pausedStatus.style.backgroundColor = '';
            }
        }

        function teleportPlayer() {
            if (teleports > 0) {
                let newPlayerPosition;
                do {
                    newPlayerPosition = {
                        x: Math.floor(Math.random() * (COLS - 2)) + 1,
                        y: Math.floor(Math.random() * (ROWS - 2)) + 1
                    };
                } while (maze[newPlayerPosition.y][newPlayerPosition.x] !== 0 ||
                        monsters.some(monster => Math.abs(monster.x - newPlayerPosition.x) <= 3 && Math.abs(monster.y - newPlayerPosition.y) <= 3));
        
                // Update both grid and pixel positions
                player.x = newPlayerPosition.x;
                player.y = newPlayerPosition.y;
                
                // Instantly move to new position (no animation)
                playerPixelPos = {
                    x: player.x * CELL_SIZE,
                    y: player.y * CELL_SIZE
                };
                playerTargetPos = { ...playerPixelPos };
        
                teleports--;
                // Pause the game after teleporting
                isPaused = true;
                updateHUD();
            }
        }

        function gameLoop() {
            if (!gameStarted) {
                requestAnimationFrame(gameLoop);
                return;
            }
        
            drawMaze();
            updatePositions();
            drawPlayer();
            drawMonsters();
            if (!isPaused) {
                moveMonsters();
                checkCollision();
            }
            requestAnimationFrame(gameLoop);
        }


        document.addEventListener('keydown', (e) => {

            const key = e.key;

            if (key === 'ArrowRight') {
                playerDirection = 'right';
            } else if (key === 'ArrowLeft') {
                playerDirection = 'left';
            } else if (key === 'ArrowUp') {
                playerDirection = 'up';
            } else if (key === 'ArrowDown') {
                playerDirection = 'down';
            }

            if (key === ' ') {
                isPaused = !isPaused;
                if (!isPaused) {
                    levelAnnouncement.classList.remove('visible');
                }
                updateHUD();
                return;
            }

            if (isPaused) return;

			const newX = player.x + (e.key === 'ArrowRight' ? 1 : e.key === 'ArrowLeft' ? -1 : 0);
			const newY = player.y + (e.key === 'ArrowDown' ? 1 : e.key === 'ArrowUp' ? -1 : 0);

			if (newX >= 0 && newX < COLS && newY >= 0 && newY < ROWS && maze[newY][newX] !== 1) {
				// Only allow movement if player has reached their current target
				if (Math.abs(playerPixelPos.x - playerTargetPos.x) < 0.1 && 
					Math.abs(playerPixelPos.y - playerTargetPos.y) < 0.1) {
					player.x = newX;
					player.y = newY;
					playerTargetPos = {
						x: player.x * CELL_SIZE,
						y: player.y * CELL_SIZE
					};
				}

				if (maze[newY][newX] === door) {
                    currentLevel++;
                    isPaused = true;
                    if (currentLevel >= max_level) {
                        alert('Congratulations! You won the game!');
                        currentLevel = 1;
                        teleports = 1;
                    }
                    initGame();
                }
        }
            if (e.key === 't' || e.key === 'T') {
                teleportPlayer();
            }
        });

        function resizeCanvas() {
            const container = document.getElementById('container');
            const sidebar = document.getElementById('sidebar');
            const maxWidth = window.innerWidth * 0.95 - sidebar.offsetWidth - 40;
            const maxHeight = window.innerHeight * 0.95;

            CELL_SIZE = Math.min(
                Math.floor(maxWidth / COLS),
                Math.floor(maxHeight / ROWS)
            );

            canvas.width  = COLS * CELL_SIZE;
            canvas.height = ROWS * CELL_SIZE;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        gameLoop();
    </script>
</body>
</html>
